\documentclass[11pt]{article}

\usepackage[english]{babel}

\usepackage[letterpaper,top=3cm,bottom=3cm,left=3cm,right=3cm,marginparwidth=1cm]{geometry}

\usepackage{algorithm, algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage[backend=biber, style=numeric, maxbibnames=9, sorting=none]{biblatex}
\addbibresource{sample.bib}
\usepackage{csquotes}
\usepackage{graphicx}
\usepackage[parfill]{parskip}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{cleveref}
\usepackage{setspace}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}
\renewcommand{\qedsymbol}{\ensuremath{\blacksquare}}

\begin{document}

\doublespacing

\begin{titlepage}
  \begin{center}
    {\Large \textbf{Computing with real irreducible representations of finite
    groups}}

    \vspace{3cm}

    \includegraphics[width=64mm]{oxlogo.png}

    \vspace{3cm}

    %{\large
    %Pavol KollÃ¡r \par
    %Corpus Christi College \par
    %University of Oxford \par
    %\vspace{1cm}
    %Supervisor: Dr. Dmitrii Pasechnik
    %}
    {\large Candidate Number: XXXXXXX}

    \vspace{3cm}

    \emph{Final Honour School of Mathematics and Computer Science Part C} \par
    Trinity 2023 \par

  \end{center}
\end{titlepage}

\newpage

\section{Abstract}
Representation theory of finite groups over complex numbers is very well
understood, in particular it is classically known that all such representations
of a group $G$ of exponent $n$ may be realised over cyclotomic numbers of degree
$n$. Real representations, i.e. these ones realised by matrices with real
entries, while important in applications, are understood much less.

It was open for a long time whether real representations of $G$ may be realised
over degree $n$ real cyclotomics; it was recently shown by Dmitrii Pasechnik to
be the case, cf. \cite{Pas21}.

The latter describes an algorithm to produce such a realisation. The main part
of the project will be to produce an implementation of this algorithm in one of
computer algebra systems, most probably in GAP or in Sagemath.

The project can be viewed as a continuation of work carried out by Dmitrii
Pasechnik and his student Kaashif Hymabaccus in \cite{Hymabaccus2020}.

\textbf{Prerequisites}: some maths background, in particular in algebra,
interest in open-source software.

\newpage

\tableofcontents

\newpage

\section{Introduction}

In representation theory of finite groups, working over complex numbers is the
most understood. This is, in part, due to the fact that $\mathbb{C}$ is an
algebraically closed field. There are also some powerful results for this case of
representations dating back to Brauer \cite[(10.3)]{ISAACS}, which
states: ``A group $G$ with exponent $n$ (cf. \cref{def:exponent}) may be
realised over (complex) cyclotomic numbers of degree $n$
(cf. \cref{sec:extensions}).''

Meanwhile, for real numbers, the answer is not so simple and it has been an open
question until recently, whether these complex representations can be brought
``down'' to reals. One reason for doing this is to bring the dimension of the
field down. If $G$ is realised over a complex field $F$, but \textit{can} be
realised only over its real part $F \cap \mathbb{R}$, then we halved the required
dimension. This allows algorithms using these to use less memory and less time.

This work can be viewed as a continuation and extension of the $2019$ work of
Kaashif Hymabaccus and Dmitrii Pasechnik about decomposing a representation into
irreducibles \cite{Hymabaccus2020}. More specifically, in this project, the main
focus is to take in a complex irreducible representation and, if possible,
make it real. Given that both these projects were aimed at the GAP system,
together, one can now take a representation, decompose it into irreducibles, and
then change some of those irreducibles into real irreducibles, which is very
powerful for applications, such as (extremal) combinatorics, physics, and
group theory.

In this project, we will efficiently implement the algorithm presented
in \cite{Pas21} by Dmitrii Pasechnik, and improve some its parts. Another aim of
ours is to make this into a fully operational addition to the GAP package
``RepnDecomp'' that \cite{Hymabaccus2020} worked on. The latter is already
included in the standard GAP distribution, so in this way we are enhancing this
open source system.

\subsection{Outline of the report}
In \cref{sec:bg}, we will introduce most of the definitions and notation used
throughout this project. These include parts of linear algebra, representation
theory, groups, field extensions, and the main programming language we used.

The \cref{sec:alg} describes most of the algorithm that \cite{Pas21} came up
with. We also fill in some of the proofs and details not mentioned in his work.

In \cref{sec:pari}, we discuss the problem of solving the ``norm equation''. For
this, we call on the help of a different computer maths system - PARI/GP.
Furthermore, we explain a bit about how to make these systems talk with each other.

In \cref{sec:kronecker}, we shall see the tricky condition of ``representation
invariance'', as well as how to translate it into a condition solvable by a
computer. This also leads to a simplification and a speed-up
in the initial algorithm in \cite{Pas21}.

Finally, in \cref{sec:end}, we summarise the end result of the project. We also
provide a high-level overview of the full algorithm created during this project.

\newpage

\section{Background} \label{sec:bg}

This section is dedicated to present the background needed for
this project. Some notation is standard, other is not. Parts of linear algebra
and group theory are assumed knowledge.

\subsection{Representation Theory}

For this subsection, let $G$ be a finite group, and let $V$ be a vector space.
The \textit{group of automorphisms} of $V$ is denoted $GL(V)$. For our purposes,
we will only consider cases where $V$ is a finite dimensional vector space over
$\mathbb{R}$ or $\mathbb{C}$. Given this, we shall associate $GL(V)$ with the
appropriate invertible matrices over the canonical basis vectors.
\begin{definition}
  A \textbf{representation} of $G$ is a homomorphism $\rho: G \rightarrow GL(V)$.
\end{definition}
For example, here is a $2$-dimensional representation of
$C_4 = \{e, x, x^2, x^3\}$:
\setstretch{1.6}
\[\rho(e) = \begin{bmatrix}
  1 & 0 \\ 0 & 1
\end{bmatrix}, \rho(x) = \begin{bmatrix}
  0 & i \\ i & 0
\end{bmatrix}, \rho(x^2) = \begin{bmatrix}
  -1 & 0 \\ 0 & -1
\end{bmatrix}, \rho(x^3) = \begin{bmatrix}
  0 & -i \\ -i & 0
\end{bmatrix}\]
\doublespacing
\begin{definition} \label{def:rep_iso}
  A representation $\rho: G \rightarrow GL(V)$ is \textbf{isomorphic} to
  $\sigma: G \rightarrow GL(W)$, when there exists a map $b: V \rightarrow W$,
  such that $b \circ \rho(g) = \sigma(g) \circ b$ for all $g \in G$ and for any
  vector.
\end{definition}
Viewing everything as matrices, we may interpret such $b$ as a change-of-basis matrix.
\begin{definition}
  Let $\rho: G \rightarrow GL(V)$ be a representation and let $U$ be a linear subspace of $V$.
  Then $U$ is \textbf{$G$-stable} if $\rho(g)(u) \in U$ for all $g \in G, u \in U$.
\end{definition}
From the previous definition stems an important follow-up definition of irreducibility, one of the
core notions of representation theory. In a sense, these irreducible representations are our building blocks.
\begin{definition}
  The representation $\rho: G \rightarrow GL(V)$ is called \textbf{irreducible} (sometimes \textbf{simple}) if
  $V$ is not the zero vector space, and if $U \leq V$ is $G$-stable, then $U = \{0\}$ or $U = V$.
\end{definition}
Lastly, we need the notion of a representation character. For our purposes, we restrict this definition to complex numbers.
\begin{definition}
  Let $\rho: G \rightarrow GL(V)$ be a complex representation of $G$. The character of $\rho$ is the function
  \[\chi_\rho: G \rightarrow \mathbb{C}, \chi_\rho(g) = \textnormal{tr} \rho(g).\]
\end{definition}
The important fact of representation theory is that, up to isomorphism, the character determines the representation.

\subsection{Field extensions} \label{sec:extensions}

Specifically, we will be using and talking about the extensions of rational
numbers. The most important one of which (for us) are the cyclotomic numbers. For
a specific degree $n$ they are denoted $\mathbb{Q}(\zeta_n)$. Here, $\zeta_n$ is
a primitive $n^{\text{th}}$ root of unity, which means that the equation
$x^n - 1 = 0$ has precisely the (distinct and complex) roots
$\zeta_n, \zeta_n^2, \ldots, \zeta_n^n = 1$. For our purposes, we
shall simply take $\zeta_n = e^{\frac{2\pi i}{n}}$.
\begin{definition} \label{def:exponent}
  The \textbf{exponent} of $G$ is the smallest $n \in \mathbb{N}$, such that for
  all $g \in G$ we have $g^n = 1_G$.
\end{definition}

These specific extensions are important to us, because of the aforementioned
result due to Brauer in \cite[(10.3)]{ISAACS}. This result states that for any
finite group $G$ with exponent $n$ and for any complex irreducible character of
this group, there is a complex representation that utilizes only the cyclotomic
numbers $\mathbb{Q}(\zeta_n)$ in the matrix entries. We say that this
representation is \textit{realised over} the $\mathbb{Q}(\zeta_n)$.

Furthermore, the group characters contain, among other things, information about
whether the representation can be realised over the real numbers.
\begin{definition} \label{def:fsi}
  Let $\rho: G \rightarrow GL(V)$ be a complex representation of $G$. Let $\chi$ be the character
  of this representation. The \textbf{Frobenius-Schur indicator} is
  \[f = \frac{1}{\lvert G \rvert} \sum_{g \in G}\chi(g^2).\]
\end{definition}
If the representation is irreducible, then we call its character irreducible.
Given that the character is irreducible, we know that $f \in \{-1, 0, 1\}$.
The case that is interesting to us is when $f = 1$, since that means the
representation \textit{can be} real valued (that is, it can map to matrices whose
entries are all real numbers). As proved in \cite{Pas21} (and as we implemented
in this project), these representations can be realised over
$\mathbb{R} \cap \mathbb{Q}(\zeta_n)$.

\subsection{GAP}

Almost all programming in this project is done in the computer algebra system GAP
\cite{GAP4}. This system stores precise rational numbers, and can also represent
cyclotomic numbers in full generality. This will be advantageous for us.

Because we shall describe the code, sometimes instead of saying $\zeta_n$, we
will say $\text{E}(n)$, which is how GAP denotes these primitive roots. For
example, $i = \text{E}(4)$ and $1 = \text{E}(6) + \text{E}(6)^5$. Note that while
$\zeta_4 = -i$ is a legitimate choice, it is non-standard and GAP defaults
to the former.

One more note is that GAP's function $\textsf{SolutionMat}(M, v)$ solves the equation
$x \cdot M = v$ for a \textit{row} vector $x$. In other words, it is solving a system
of linear equations. However, in the pseudocode, we present this function in the
more usual column formulation: $M \cdot x = v$. To switch between
the two, we can simply transpose the matrix.

\newpage

\section{Computing real representations}

\subsection{Algorithm of Dr. Pasechnik} \label{sec:alg}

Let us begin by fixing some notation, following the notation in his paper \cite{Pas21}.

Let $G$ be a finite group, $n$ its exponent, $\chi$ one of its irreducible complex characters. 
Following the GAP naming, we shall say $\chi \in \textsf{Irr}(G)$. For starters, if we want to,
we can check that the Frobenius-Schur indicator is indeed $1$ for this character and this group.
For that, we use the naive summing code, or utilise the GAP
\href{https://docs.gap-system.org/doc/ref/chap71_mj.html#X7FD3D3047DE6381E}{built-in Indicator} functions:

\begin{algorithm}
  \caption{NaiveFSICheck}
  % \label{if needed}
  \begin{algorithmic}
    \State $fsi \gets 0$
    \For{$g \in G$}
      \State $fsi \gets fsi + \chi(g^2)$
    \EndFor
    \State \textbf{return} $fsi > 0$\Comment{No need to divide, as here, $fsi \in \{-|G|,0,|G|\}$.}
  \end{algorithmic}
\end{algorithm}

One trick we can do with the naive code is to check the character values. If any of them are
complex, but \textit{not} real, then the representation cannot be real realisable. Recall that
the character is invariant for isomorphic copies of the representation. If
$\chi(g) = \text{tr}\rho(g) \in \mathbb{C}$, then at least one of the diagonal entries
must be complex, so the matrix is not real.

Adding more notation, let $\zeta_n = e^{\frac{2\pi i}{n}}, F=\mathbb{Q}(\zeta_n)$.
Brauer's theorem in \cite[(10.3)]{ISAACS} states that there is a
representation $\rho_\chi: G \rightarrow GL_d(F)$, which affords the irreducible
character $\chi$. Here, $d$ is a natural number, the so called degree of the
representation. It is a fact of representation theory that $d = \chi(1_G)$.
If this representation was real already, there would be nothing for us to prove.
Therefore, we may as well take $n \geq 3$, for otherwise, we already have a
\textit{real} representation.

\begin{theorem}
  Let $E = \mathbb{Q}(\zeta_n) \cap \mathbb{R} = F \cap \mathbb{R} \subset F$.
  Also let $D = \mathbb{Q}(\zeta_n + \overline{\zeta_n})$.
  Then $E = D$, i.e. these two fields are identical.
\end{theorem}
\begin{proof}
  First of all, $D$ is a real field extension, since $\overline{\zeta_n + \overline{\zeta_n}} = \zeta_n + \overline{\zeta_n}$.
  Also, $D \subseteq F$, because any $d \in D$ is also in $F$, just having the same coefficients for $\zeta_n^i$ and $\overline{\zeta_n^i}$.
  Thus, $D \subseteq E$. Given that both are fields, such a subset relation means that $D \hookrightarrow E$ is a field extension.
  In the notation of field extension degrees, $[E:D] \geq 1$.

  The latter part of the proof requires some Galois Theory (one of many good
  materials to refer to for Galois theory is \cite{milne2022}).
  Complex conjugation is a field automorphism of $F$, with $E$ being precisely
  the fixed subfield.   By Artin's Lemma, this means that $E \hookrightarrow F$
  is a (Galois, in fact) extension. We note that by assumption, $E \subseteq F$.
  Furthermore, $\zeta_n \in F$, but $\zeta_n \notin E$, so this extension is
  non-trivial, which means $[F:E] \geq 2$.

  Now consider the polynomial $f(x) = x^2 - (\zeta_n + \overline{\zeta_n})x + 1$. We constructed this
  polynomial, so that $f(\zeta_n) = 0$, since $\zeta_n \cdot \overline{\zeta_n} = 1$. This means
  that $F$ is a quadratic extension over $D$, which gives $[F:D] = 2$. To finish, we utilise the Tower Law
  applied to the extensions $D \hookrightarrow E, E \hookrightarrow F$:
  \[2 = [F:D] = [F:E] \cdot [E:D] \geq 2 \cdot 1 = 2.\]
  Thus, the two degree inequalities must hold with equality, that is $[F:E] = 2, [E:D] = 1$.
  But $[E:D] = 1$ means that $E = D$, as claimed.
\end{proof}

We shall return to this fact later. Now let $G$ be generated by
$g_1, \ldots, g_m$, and let $M_1 = \rho(g_1), \ldots, M_m = \rho(g_m)$.
We note these matrices $M_1, \ldots, M_m \in GL_d(F)$. To find a representation
that is isomorphic to $\rho$ and real, we would need \textit{these} matrices to
be real by a change of basis matrix $Q$ (cf. \cref{def:rep_iso}). More explicitly,
we want a $Q \in GL_d(F)$, such that for all $M_i$, the following holds:
$QM_iQ^{-1} \in GL_d(E)$.

The paper \cite{Pas21} states and proves theorems how to obtain such matrix $Q$.
Here we will only mention the statements of those and prove some of the omitted
details. For full proofs, refer to \cite[Lemma 3.1, 3.2]{Pas21}.
\begin{lemma}
  Let $\mathbf{\Sigma} = \sum_{h \in \rho(G)} h^T\overline{h}$. Then the matrix
  $\mathbf{\Sigma}$ is Hermitian and positive definite. It is also the matrix of
  a quadratic $\rho(G)$-invariant form, in the sense that for all $g \in \rho(G)$,
  the equation $g^T\mathbf{\Sigma}\overline{g} = \mathbf{\Sigma}$ holds.
\end{lemma}
\begin{proof}
  We have three claims to prove and we will do so one by one:
  \begin{itemize}
    \item $\mathbf{\Sigma}$ is Hermitian. That is to say, it is a matrix, such that its conjugate
    transpose is itself. In symbols, we want $\mathbf{\Sigma} = \overline{\mathbf{\Sigma}}^T = \mathbf{\Sigma}^*$.
    By design, both conjugation and transposition distribute over a sum. To see what the operation
    does to individual terms, note:
    \[\left(h^T\overline{h}\right)^* = \overline{\left(h^T\overline{h}\right)}^T =
    \left(\overline{h}^Th\right)^T = h^T\left(\overline{h}^{T^T}\right) = h^T\overline{h},\]
    as required. Hence, $\mathbf{\Sigma} = \mathbf{\Sigma}^*$ truly holds.
    \item $\mathbf{\Sigma}$ is positive definite. For this, we have to show that for any row vector $v \in F^d$
    we have $v\mathbf{\Sigma}v^* \geq 0$. So fix any $v$ and note that pre- and post-multiplying by
    a vector is a linear operation, so we have $v\mathbf{\Sigma}v^* = \sum_{h \in \rho(G)} vh^T\overline{h}v^*$.
    Also note that $\overline{h} = h^{T^*}$, from which $\overline{h}v^* = h^{T^*}v^* = \left(vh^T\right)^*$. Therefore:
    \[v\mathbf{\Sigma}v^* = \sum_{h \in \rho(G)} \left(vh^T\right)\left(vh^T\right)^* = \sum_{h \in \rho(G)} \left\lVert vh^T\right\rVert \geq 0,\]
    because each of those complex norms is non-negative.
    \item $\mathbf{\Sigma}$ is $\rho(G)$-invariant. Fix a $g \in \rho(G)$ and start from the mentioned claim:
    \[g^T\mathbf{\Sigma}\overline{g} = g^T\sum_{h \in \rho(G)}h^T\overline{h} \overline{g} = \sum_{h \in \rho(G)}g^Th^T\overline{h} \overline{g}=
    \sum_{h \in \rho(G)} \left(hg\right)^T \overline{(hg)} \color{red}=\color{black} \sum_{k \in \rho(G)} k^T \overline{k} = \mathbf{\Sigma}.\]
    The red equality follows from the fact that both $g,h$ are group elements and that the Cayley tables are Latin squares, so
    summing over $h$ of the expression $hg$ is the same as just summing over the group elements $k$.
  \end{itemize}
\end{proof}

Let $\mathbf{M}$ be a non-zero matrix of a quadratic $\rho(G)$-invariant form.
In fact, for real-realisable representations, such a matrix is symmetric. It is
also unique, up to scaling. For a proof of these facts about the quadratic
invariant form, we refer the reader to \cite[(4.14)]{ISAACS}. We postpone the
explanation how to obtain this matrix $\mathbf{M}$ until \cref{sec:kronecker}.

Given these two matrices, he proves in his paper that setting $P = \mathbf{\Sigma}^{-1}\mathbf{M} \in GL_d(F)$
gives $P$ the ``invariance'' property $P\rho(g) = \overline{\rho(g)}P$ for all $g \in G$. Furthermore, $P\overline{P} = \mu I$,
for some $0 < \mu \in E$. Let $x\in F$ be such that $x\overline{x} = \mu$. We want this, because we need
to have $P\overline{P} = I$, so scaling $P$ by dividing it by $x$ gives us what we want (and, of course,
the ``invariance'' property is preserved under scaling).

To obtain such an $x$, we must solve the equation $x\overline{x} = \mu$, so called ``norm equation''.
For this, we use the software PARI/GP. Details of using PARI/GP and
communicating with it from within GAP are in the \cref{sec:pari}. If $d$ is odd, then
there is neat trick to skip needing to solve the norm equation, cf. \cite[Lemma 3.4]{Pas21}.

With $P$ scaled \cite[Lemma 3.3]{Pas21} gives that $Y = \xi P$ and $Q = \overline{Y} + \overline{P}Y = \overline{\xi P} + \xi I$
gives us the desired result of basis change, such that $QM_iQ^{-1} \in GL_d(E)$, provided
that $\xi \neq 0$ and $-\xi/\overline{\xi}$ is \textit{not} an eigenvalue of $P$.
This $\xi$ can be picked randomly from $F$, or we can use the following observation:
\begin{lemma}\label{lem:derandomising}
  Given that $n$ is the exponent of the group $G$, let $c = 4$ if $4|n$, otherwise let $c$ be
  the smallest odd prime dividing $n$. Then for at least one $a \in \{1,2,\ldots,d+1\}$, we have
  that $-\xi/\overline{\xi}$ is indeed \textbf{not} an eigenvalue of $P$.
\end{lemma}
\begin{proof}
  Note that there are at most $d$ different eigenvalues of $P$. Let $\xi_a = a + \zeta_c, \xi_b = b + \zeta_c$.
  Now assume $-\xi_a/\overline{\xi_a} = -\xi_b/\overline{\xi_b}$. Then we manipulate the equation:
  \begin{align*}
    \frac{-\xi_a}{\overline{\xi_a}} = \frac{-\xi_b}{\overline{\xi_b}}
    & \Leftrightarrow \frac{-a - \zeta_c}{\overline{a + \zeta_c}} = \frac{-b - \zeta_c}{\overline{b + \zeta_c}} \\
    & \Leftrightarrow (a + \zeta_c)(b + \overline{\zeta_c}) = (b + \zeta_c)(a + \overline{\zeta_c}) \\
    & \Leftrightarrow ab + a\overline{\zeta_c}+b\zeta_c + \zeta_c\overline{\zeta_c} = ab + b\overline{\zeta_c}+a\zeta_c + \zeta_c\overline{\zeta_c} \\
    & \Leftrightarrow a\overline{\zeta_c} + b\zeta_c - b\overline{\zeta_c} - a\zeta_c = 0 \\
    & \Leftrightarrow (a - b)(\overline{\zeta_c} - \zeta_c) = 0
  \end{align*}
  From first to the second line, we used that $a,b\in\mathbb{N}$, from which $\overline{a + \zeta_c} = a + \overline{\zeta_c}$.
  In the end, we have two choices; either $\overline{\zeta_c} = \zeta_c$, which is impossible, as $c \geq 3$ by assumption.
  The only other possibility is that $a=b$. To finish the argument, we notice that we have $d+1$ values to pick from,
  but only at most $d$ eigenvalues. Thus, at least one is \textit{not} an eigenvalue.
\end{proof}
With this in mind, given $P$, we can calculate a viable $Q$, as presented in \cref{alg:comp_q}.
\begin{algorithm}
  \caption{ComputeQ}
  \label{alg:comp_q}
  \begin{algorithmic}
    \State $n \gets \textsf{Exponent}(G)$\Comment{Either compute fresh or let it be be given.}
    \If{$4|n$}
      \State $c \gets 4$
    \Else
      \State $primes \gets \textsf{PrimeDivisors}(n)$\Comment{GAP function; gives the primes in ascending order.}
      \If{$primes[1] = 2$}\Comment{GAP is 1-indexed, not 0-indexed.}
        \State $c \gets primes[2]$
      \Else
        \State $c \gets primes[1]$
      \EndIf
    \EndIf
    \State $Q \gets \textsf{NullMat}(d, d)$\Comment{A $d\times d$ zero matrix, so we enter the loop.}
    \State $a \gets 1$
    \While{$\textsf{det}(Q) = 0$}
      \State $\xi \gets a + \zeta_c$
      \State $Y \gets \xi \cdot P$\Comment{$P$ has been previously calculated.}
      \State $Q \gets \overline{Y} + \overline{P}Y$
      \State $a \gets a+1$\Comment{By \cref{lem:derandomising}, there are at most $d+1$ iterations.}
    \EndWhile
    \State \textbf{return} $Q$\
  \end{algorithmic}
\end{algorithm}

In GAP, representations as well as many other group homomorphisms are defined by mapping generators
to the target elements. In the beginning, we were given (left). Having obtained the proper $Q$, we
can real-realise the representation by conjugation (right). This is the reason we insisted on $\text{det}(Q) \neq 0$.
\setstretch{1.6}
\[\rho(g_1) = M_1, \ldots \rho(g_m) = M_m.~~~~~~~~~~~~~~~\rho(g_1) = QM_1Q^{-1}, \ldots \rho(g_m) = QM_mQ^{-1}.\]
\doublespacing
Labelling $gens_G = \left[g_1,\ldots,g_m\right], gens_{image} = \left[QM_1Q^{-1}, \ldots, QM_mQ^{-1}\right]$, GAP returns
\begin{verbatim}
  GroupHomomorphismByImages(G, Group(gens_image), gens_G, gens_image)
\end{verbatim}
\newpage
\subsection{Norm equation and PARI/GP} \label{sec:pari}

The other programming tool use in this project is PARI/GP \cite{PARI2}
(from now on, just Pari). Pari has a powerful toolkit for working with number
fields, which is another word for algebraic extensions of $\mathbb{Q}$. Thus, it
will be the perfect tool for us to find the norm roots of the scaled identity
$x\overline{x}=\mu$. It is also our program of choice, because Pari can be called
and executed directly from the running GAP program.

Pari works with these fields in a much more abstract way, specifically by manipulating
the generating polynomials for these extensions and then specifying numbers based on
their expressions as the roots of these polynomials. For the rest of this section,
fix the $P$ that we calculated before, such that $P\overline{P} = \mu I$.

Looking at \cite[Theorem 1.1]{Pas21}, we know that the equation $x\overline{x}=\mu$
is solvable in the complex cyclotomics of degree $n = \textsf{Exponent}(G)$. So let
us specify the real and the complex cyclotomic fields in Pari:
\begin{align*}
  E = \textsf{bnfinit}(\textsf{galoissubcyclo}(n,-1,0,z));
  F = \textsf{rnfinit}(E, y^2 + 1);
\end{align*}
Here, since the roots are what is important to us, $y = i = \text{E}(4)$ and
$z = \zeta_n + \overline{\zeta_n} = \text{E}(n) + \text{E}(n)^{n-1}$.
With the two relevant number fields, we are ready to compute the norms:
\begin{align*}
  norms = \textsf{rnfisnorminit}(E\textsf{.pol}, F\textsf{.pol}, 1); &~~\text{\# Set up.}\\
  norm\_root = \textsf{rnfisnorm}(norms, \mu); &~~\text{\# Find out if it is a norm of an element.}\\
  x = \textsf{liftall}(norm\_root[1]); &~~\text{\# Extract the solution to } x\overline{x} = \mu.
\end{align*}

Documentation and details for all of the keywords can be found
\href{https://pari.math.u-bordeaux.fr/dochtml/html/General_number_fields.html}{here}.
The $x$ in the final expression is a binomial expression in $y,z$ and we have to now
translate that back into GAP and its cyclotomic number expressions.
Since we get the result as a string, this is as simple as string replacement,
and letting GAP simplify the mathematical expression on its own.

There are two more points worth mentioning here. First, while we do have a guarantee
that the equation $x\overline{x}=\mu$ has a solution in the complex cyclotomics of
degree $n = \textsf{Exponent}(G)$, if we can help it, we would like a solution that
has a low cyclotomic degree. So our full algorithm firstly tries to find a solution
in cyclotomics of degree $d$, where $\mathbb{Q}(\zeta_d)$ is the smallest field
which contains \textit{all} elements of $P$. The solution need not exist in this
case, but if it does, we (may) get a simpler solution.

Second point, which is much more important, is the translation of the \textit{norm}
into Pari. Now, if $\mu \in \mathbb{Q}$, we are fine, Pari works with precise
fractions too. However, the expression for $\mu$ may already include some
$\text{E}(a)$'s, in which case, it is not so easy. This is because Pari does
\textbf{not} use these primitive roots of $1$, at least, not directly.

To get around this, we define the real field $E$ first. Then instead of passing the
norm $\mu$ directly from GAP to Pari, we will first calculate its expression in
$z = \zeta_n + \overline{\zeta_n}$. Let $\mu = \sum_{i = 0}^{n-1} a_n \zeta_n^i$.
Our goal now is to find $b_i$, such that $\mu = \sum_{j = 0}^{k} b_j z^j$.
This constitutes solving another linear system of equations, namely to equate the
coefficients in the $z$-sum and $\mu$. See \cref{alg:translate}. Once we obtain
the vector of $b_i$'s, we have to transform it into a string of coefficients and
powers, which is the latter part of the algorithm.

\begin{algorithm}
  \caption{GapToPari\_Translate}
  \label{alg:translate}
  \begin{algorithmic}
    \State $d, \mu$\Comment{Supplied function arguments; respectively, the degree and the norm we seek.}
    \State $k \gets \phi(d) / 2$ \Comment{The upper bound of the $z$-sum.}
    \State $symmetric \gets E(d) + ComplexConjugate(E(d))$
    \State $conversion\_matrix \gets [~]$
    \For{$power \in [0, 1, \ldots, k]$}
      \State $\textsf{Add}(conversion\_matrix, \textsf{CoeffsCyc}(symmetric^{power}, d))$\Comment{Row of coefficients.}
    \EndFor
    \State $\mathbf{b} \gets \textsf{SolutionMat}(conversion\_matrix^T, \textsf{CoeffsCyc}(\mu, d))$\Comment{Vector of $b_i$'s.}
    \State $s = \textsf{String}(b_0)$
    \For{$power \in [1, 2, \ldots, k]$}
      \State $c \gets b_{power}$
      \If{$c>0$}
        \State $\textsf{Append}(s, +c^*z \string^ power)$
      \ElsIf{$c<0$}
        \State $\textsf{Append}(s, c^*z \string^ power)$ \Comment{We omit the negative sign, as $\textsf{String}(c)$ has it.}
      \EndIf
    \EndFor
  \end{algorithmic}
\end{algorithm}

\subsection{Kronecker products} \label{sec:kronecker}

Now we turn to calculating the appropriate matrix $\mathbf{M}$, that is, a $d\times d$
matrix such that is it $\rho(G)$-invariant.
Unlike for $\mathbf{\Sigma}$, here we need the following condition to hold:
\[\forall g \in G: \rho(g)^T\mathbf{M}\rho(g) = \mathbf{M}. \label{eq:m_require}\tag{$\dagger$}\]
Unlike in the $\mathbf{\Sigma}$ case, we cannot simply calculate the expression for $\mathbf{M}$.
However, it is clear that if the condition holds for the generators of $G$, then we are done.
Fix a generator $g \in G$ and let us look closer at the matrices $\rho(g) = [g_{i,j}], \mathbf{M} = [m_{i,j}]$.
Multiplying the first two matrices on the left-hand-side, we get:
\[\mathbf{L}_{i,j} = (\rho(g)^T\mathbf{M})_{i,j} = \sum_{k=1}^{d}g_{k,i}m_{k,j}.\]
Multiply by $\rho(g)$ on the right to get a full expression for the left-hand-side:
\[m_{i,j} = \mathbf{M}_{i,j} = \text{LHS}_{i,j} = (\mathbf{L}\rho(g))_{i,j} =
\sum_{s=1}^{d}\mathbf{L}_{i,s}g_{s,j} = \sum_{s=1}^{d}\sum_{k=1}^{d}g_{k,i}m_{k,s}g_{s,j}. \label{eq:product} \tag{$\clubsuit$}\]
\begin{definition}
  Let $A = [a_{i,j}], B = [b_{i,j}]$ be $d\times d$ matrices. Then the
  \textbf{Kronecker product} of $A, B$ is denoted $A \otimes B$ and it is the matrix
  \setstretch{1.25}
  \[A \otimes B = \begin{bmatrix} a_{1,1}B & \cdots & a_{1,d}B\\
    \vdots & \ddots & \vdots \\ a_{d,1}B & \cdots & a_{d,d}B\end{bmatrix}\]
  \doublespacing
  Here, each ``element'' of this matrix is itself a block of $d\times d$ entries.
  In what follows, we will also need the expression for the entries of
  this big $d^2 \times d^2$ matrix. We have that the $i,j$ element in the
  Kronecker product is:
  \[(A \otimes B)_{i,j} = a_{\lceil i/d \rceil, \lceil j/d \rceil}\cdot b_{(i-1)\pmod d+1,(j-1)\pmod d+1}\]  
  \textbf{Note:} here, we are $1$-indexing the matrices.
\end{definition}
Having defined that, let us consider $\rho(g)^T \otimes \rho(g)^T$, specifically, let us list out the elements of the first row.
\[g_{1,1}g_{1,1};~g_{1,1}g_{2,1};~\ldots;~g_{1,1}g_{d,1};~g_{2,1}g_{1,1};~\ldots g_{2,1}g_{d,1};~\ldots, g_{d,1}g_{d,1}.\]
Also, let $\mathbf{v}$ be the vector of flattened matrix $\mathbf{M}$, done row-wise. That is:
\[\mathbf{v} = [m_{1,1};~ m_{1,2};~ m_{1,3};~ \ldots;~ m_{1,d};~ m_{2,1};~ \ldots;~ m_{2,d};~ \ldots m_{d,d}].\]
Notice now that if we scalar-multiply $\mathbf{v}$ and the first row of $\rho(g)^T \otimes \rho(g)^T$, we get exactly
the expression in \cref{eq:product} for $m_{1,1}$. In fact, by simple index manipulation, one
can see this holds for the rows, given what the expression for $(A \otimes B)_{i,j}$ is.
Therefore, the condition of \cref{eq:product} changes to $\left(\rho(g)^T \otimes \rho(g)^T\right)\mathbf{v}^T = \mathbf{v}^T$,
or, even further, $\left(\rho(g)^T \otimes \rho(g)^T - I_d\right)\mathbf{v}^T = \mathbf{0}$.

Note that we require $\mathbf{M}$ to not be the zero matrix, so the trivial solution of $\mathbf{v} = \mathbf{0}$
is not what we want. However, we know that this non-zero $\mathbf{M}$ exists and that it is unique
up to scaling. So, to solve the aforementioned system of linear equations, we can fix $m_{1,1} = 1$
and attempt to solve the remaining $d^2-1$ equations with the constraint. If it succeeds, we have
a vector for $\mathbf{M}$ that we can reshape to reconstruct it. If it fails, it means this coordinate
is $0$ in the matrix we are after and we try the next coordinate in the row.

More than $\mathbf{M}$ being non-zero, we in fact require $\text{det}(\mathbf{M}) \neq 0$, cf. \cite[Proof of Lemma 3.1]{Pas21}.
This assures us that we only need to try at most $d$ times, if we are going from the first coordinate
of $\mathbf{v}$ in order, otherwise we would get a zero-row in $\mathbf{M}$, contradicting $\text{det}(\mathbf{M}) \neq 0$.
The algorithm for this non-zero solution and subsequent reconstruction is \cref{alg:nonzero}.

That was for \textit{one} of the generators of $G$. For $\mathbf{M}$ to satisfy \cref{eq:m_require},
we need to include the $\rho(g)^T \otimes \rho(g)^T - I_d$ matrix for \textit{all} generators. In
the language of linear equations, this means creating a block-matrix out of these Kronecker products
by stacking them on top of one another. In the end, we get:
\[\begin{bmatrix} \rho(g_1)^T \otimes \rho(g_1)^T - I_d\\ \vdots \\ \rho(g_m)^T \otimes \rho(g_m)^T - I_d\end{bmatrix} \mathbf{v}^T = \mathbf{0}.\]
This is what the actual algorithm computes, but \cref{alg:nonzero} does this for just \textit{one} $g_i$.

\begin{algorithm}
  \caption{NonzeroSolutionForOne\_g}
  \label{alg:nonzero}
  \begin{algorithmic}
    \State $K = \rho(g)^T \otimes \rho(g)^T$ \Comment{This is given to the algorithm from previous computation.}
    \For{$i \in [1, \ldots, d]$}\Comment{GAP is $1$-indexed. Also, we use $\textsf{det}(\mathbf{M}) \neq 0$.}
      \State $rhs\_vector \gets -K[:,i]$ \Comment{Extract the column that we fix to have $m_{1,i} = 1$.}
      \State $remaining \gets K[:,\{1, \ldots, i-1, i+1, \ldots, d^2\}]$ \Comment{Keep all others.}
      \State $maybe\_solution \gets \textsf{SolutionMat}(remaining, rhs\_vector)$\Comment{Solve the rest.}
      \If{$maybe\_solution \neq \textsf{fail}$} \Comment{GAP keyword `fail' signalizes there was no solution.}
        \State $\mathbf{v} \gets maybe\_solution[\{1, \ldots, i-1\}]$
        \State $\textsf{Add}(\mathbf{v}, 1)$ \Comment{Insert the $1$ back into the appropriate spot.}
        \State $\textsf{Append}(\mathbf{v},maybe\_solution[\{i, \ldots, d^2-1\}])$
        \State \textbf{break}
      \EndIf
    \EndFor
    \State $\mathbf{M} \gets [~]$ \Comment{We will be adding full rows.}
    \For{$i \in [0, \ldots d-1]$}
      \State $\textsf{Append}(\mathbf{M}, [maybe\_solution[\{1+i\cdot d, \ldots, (1+i)\cdot d\}]])$
    \EndFor
    \State \textbf{return} $\mathbf{M}$
  \end{algorithmic}
\end{algorithm}

\textbf{Remark:} We chose the two matrices to do a Kronecker product on carefully. Specifically,
in the left-hand-side of \cref{eq:m_require}, we had pre-multiplied $\mathbf{M}$ by $\rho(g)^T$
and post-multiplied it by $\rho(g)$. Because of how multiplication of matrices takes the \textit{rows}
of the left argument, but \textit{columns} of the right, we need to transpose the right matrix
and only then use the Kronecker product, to maintain the condition.

Having noted that, we can use this very Kronecker trick to calculate $P$ directly. Recall the chain
of conditions that were required in proving \cite[Lemma 3.2, 3.3]{Pas21}. The \cite[Lemma 3.2]{Pas21}
required $P\rho(g) = \overline{\rho(g)}P$ for all $g\in G$ and proved that
$P\overline{P} = \mu I$. In the previous section, we have seen how to obtain an
appropriate norm-root to scale down $P$ with, in order to get $P\overline{P} = I$.
This in turn is the prerequisite to proving \cite[Lemma 3.3]{Pas21}.

Therefore, in order to obtain $Q$, the key condition we are trying to
fulfill is $P\rho(g) = \overline{\rho(g)}P$. Equivalently:
$\overline{\rho(g)}^{-1}P\rho(g) = P$. Reasoning analogically as with $\mathbf{M}$,
we can change this condition into the vector form with a Kronecker product:
$\left(\overline{\rho(g)}^{-1} \otimes \rho(g)^T - I_d\right)\mathbf{v}^T = \mathbf{0}$.

What does this gain us? One way or another, we are computing the Kronecker product,
but doing it directly for $P$, we skip the calculation of
$\mathbf{\Sigma} = \sum_{h \in \rho(G)} h^T\overline{h}$. In essence, that is a
sum over the whole group that was given to us, which is a costly operation,
for example for larger symmetric groups. For those specifically, we note they only
have two generators, so employing the Kronecker trick is especially efficient.

\newpage

\section{Further comments} \label{sec:end}

In this project, we saw how to make the computer system GAP change a complex
cyclotomic representations into a real cyclotomic representation.

Further work on this project may look at larger automorphisms of the cyclotomic
field (we considered the degree $2$ action of complex conjugation). The aim there
is to further reduce the extension degree (not to be confused with the
representation degree). This would lead to more memory savings as well as nicer
and more compact expressions when working with these extensions.

To end this report, we present a high-level program that computes \textbf{all}
real representations of a given finite group $G$ with exponent $n$.
\newpage
\begin{algorithm}
  \caption{AllRealRepresentations}
  % \label{alg:ARR}
  \begin{algorithmic}
    \State $indicators \gets \textsf{Indicator}(\textsf{CharacterTable}(G), 2)$ \Comment{All the FSI's.}
    \State $characters \gets \textsf{Irr}(G)$ \Comment{All the irreducible characters.}
    \State $real\_reps \gets [~]$ \Comment{List for storing the real representations.}
    \For{$i \in [1, \ldots, \textsf{Size}(indicators)]$}\Comment{Equivalently, $i \in [1, \ldots, \textsf{Size}(characters)]$.}
      \If{$indicators[i] = 1$} \Comment{We \textit{can} realise over reals.}
        \State $gens\_G \gets \textsf{GeneratorsOfGroup}(G)$
        \State $char \gets characters[i]$
        \State $d \gets char[1]$
        \If{$d = 1$} \Comment{The character itself \textit{is} a real representation.}
          \State $\textsf{Add}(real\_reps, \rho: g \mapsto char(g))$ \Comment{Defining $\rho$ for $g \in gens\_G$ suffices.}
          \State \color{blue} \Comment{Since we are working with matrices, it should actually be $\rho(g) = [[char(g)]]$.} \color{black}
          \State \textbf{continue}
        \EndIf
        \State $arep \gets \textsf{IrreducibleAffordingRepresentation}(char)$
        \State $matrix\_gens \gets \textsf{GeneratorsOfGroup}(\textsf{Image}(arep))$
        \State $P \gets \textsf{KroneckerTrick}(d, matrix\_gens)$ \Comment{Using \cref{alg:nonzero} on all generators.}
        \State $\mu \gets \left(P\overline{P}\right)_{1,1}$ \Comment{Extract the relevant scalar.\footnotemark
        \If{$d \equiv 1 \pmod 2$} \Comment{Odd dimension trick, cf. \cite[Lemma 3.4]{Pas21}.}
          \State $P \gets P \cdot \mu^{(d-1)/2}/\det(P)$
        \Else
          \State $c \gets min\big\{k \in \mathbb{N} | \forall i,j: P_{i,j} \in \mathbb{Q}(\zeta_k)\big\}$
          \State $norm\_root \gets \textsf{PariNorms}(c, \mu)$
          \If{$norm\_root = \textsf{fail}$} \Comment{In this case, there may not be a norm root.}
            \State $norm\_root \gets \textsf{PariNorms}(n, \mu)$ \Comment{With $G$ exponent it is guaranteed success.}
          \EndIf
          \State $P \gets P / norm\_root$
        \EndIf
        \State $Q \gets \textsf{compute\_Q}(P, n, d)$ \Comment{Using \cref{alg:comp_q} for this.}
        \State $\textsf{Add}(real\_reps, \rho: g \mapsto Q^{-1} \cdot arep(g) \cdot Q)$
      \EndIf
    \EndFor
    \State \textbf{return} $real\_reps$
  \end{algorithmic}
\end{algorithm}
\footnotetext{More efficiently, we can compute $\mu = \sum_{i=1}^{d}p_{1,i} \cdot \overline{p_{i,1}}$}}

\newpage

\printbibliography[title={References}]

\end{document}